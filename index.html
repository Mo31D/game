 <!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Grand Silk Road â€” by mO</title>
<link rel="stylesheet" href="silkroad-style.css?v=1.0.0.6">
</head>

<body>

<div class="container">
  <div class="map" id="map">
    <div id="diceContainer"></div>
    <div id="greenDie" class="die"></div>
    <div id="redDie" class="die"></div>
  <div class="after-start-floating hidden-panel" id="afterStartPanel">
    <button id="resetBtn2" class="primary">ğŸŒŸ Start a new game</button>
  </div>
    <!-- ğŸ™ï¸ Floating top-right corner info -->
    <div class="floating-top-corner">
      <div id="currentTownText">price:</div>
      <div id="turnBanner">Waiting for players...</div>
    </div>

    <!-- âœ¨ Floating Sign-In Panel -->
    <div class="login-floating" id="loginPanel">
      <h2>ğŸ•ï¸ Caravan Entry</h2>
      <input id="newPlayerName" type="text" placeholder="Player name..." />
      <div class="btns">
        <button id="addPlayerBtn">Add a player</button>
        <button id="addAIPlayerBtn" class="ai">Robot ğŸ¤–</button>
        <button id="startBtn" class="primary"> Start </button>
      </div>
      <button id="resetBtn" class="reset">âŸ³</button>
    </div>
  </div>

    <!-- ğŸ§¾ Game Log -->
    <div class="log-panel" id="logPanel">
      <strong>Log</strong>
      <div id="log"></div>

      <div id="ytWrapper" style="display:none; text-align:center; margin-top:10px;">
        <iframe id="ytFrame" width="360" height="215"
          src=""
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen>
        </iframe>
      </div>
    </div>
<!-- HOWTO PANEL (English, Night-themed, place under .login-floating) -->
<div id="howtoPanel" class="howto-panel night-howto" role="region" aria-label="How to play">
  <div class="howto-top">
    <div class="howto-emoji">ğŸ”°</div>
    <div>
      <div class="howto-title">How to play â€” Quick Guide</div>
      <div class="howto-sub">First to reach <strong>$1,000,000</strong> wins!</div>
    </div>
  </div>

  <div class="howto-body">
    <ol>
      <li>Enter your name and press <strong>Start</strong> to join the caravan.</li>
      <li>Each player starts with <strong>ğŸª 0 camels</strong> and <strong>ğŸ’² 10 gold</strong>.</li>
      <li>On your turn choose: <strong>Buy ğŸª</strong>, <strong>Sell ğŸ’°</strong>, or <strong>Wait â³</strong>.</li>
      <li>Use the <strong>+ / âˆ’</strong> buttons to pick how many camels.</li>
      <li>When everyone acts, the dice are rolled and the caravan moves â€” city price changes.</li>
    </ol>

    <div class="howto-tip">ğŸ’¡ Tip: buy in cheap towns & sell in expensive towns.</div>
  </div>

  <div class="howto-actions">
    <button id="howtoClose" class="howto-btn primary">Got it â€” Close</button>
    <button id="howtoHide" class="howto-btn">Hide</button>
    <button id="howtoShowAgain" class="howto-link" style="display:none;">Show guide</button>
  </div>
</div>

<style>
/* Night / city-lights themed HowTo â€” complements body.night styles in silkroad-style.css */
.howto-panel{
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: calc(50% + 180px); /* sits under the login-floating */
  width: clamp(240px, 44%, 380px);
  z-index: 2100;
  border-radius: 12px;
  padding: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  color: #e9e6d8;
  transition: all .32s ease;
  backdrop-filter: blur(8px) saturate(120%);
}

/* Night look (stronger when body.night is active) */
.night-howto {
  background: linear-gradient(180deg, rgba(6,8,18,0.86), rgba(8,10,22,0.88));
  border: 1px solid rgba(180,150,40,0.08);
  text-shadow: 0 1px 6px rgba(0,0,0,0.6);
}

/* tiny header */
.howto-top{ display:flex; gap:10px; align-items:center; margin-bottom:8px; }
.howto-emoji{ font-size:22px; filter:drop-shadow(0 4px 10px rgba(0,0,0,0.6)); }
.howto-title{ font-weight:800; font-size:15px; color:#ffd96a; text-shadow:0 1px 6px rgba(0,0,0,0.6);}
.howto-sub{ font-size:12px; color:#cfc5a7; margin-top:2px; }

/* body */
.howto-body{ color:#d7d4c6; font-size:13px; line-height:1.3; margin-bottom:8px; }
.howto-body ol{ padding-left:18px; margin:6px 0; }
.howto-body li{ margin:6px 0; }

/* tip */
.howto-tip{ margin-top:8px; font-weight:700; color:#99f2c6; font-size:13px; }

/* actions */
.howto-actions{ display:flex; gap:8px; justify-content:flex-end; align-items:center; }
.howto-btn{ padding:7px 10px; border-radius:8px; font-weight:700; border:none; cursor:pointer; font-size:13px; }
.howto-btn.primary{ background: linear-gradient(90deg,#ffd966,#ffb84d); color:#2b1600; box-shadow: 0 6px 18px rgba(255,170,30,0.08); }
.howto-btn:hover{ transform:translateY(-2px); }

/* subtle decorative 'city lights' strip at the panel bottom */
.night-howto::after{
  content: "";
  display:block;
  height:6px;
  margin-top:10px;
  border-radius:6px;
  background: radial-gradient(circle at 10% 50%, rgba(255,220,90,0.12), transparent 8%),
              radial-gradient(circle at 30% 50%, rgba(255,120,200,0.06), transparent 8%),
              radial-gradient(circle at 60% 50%, rgba(120,220,255,0.08), transparent 8%),
              linear-gradient(90deg, rgba(255,220,80,0.06), rgba(255,120,120,0.02));
  box-shadow: 0 4px 18px rgba(0,0,0,0.6) inset;
  opacity:0.95;
  animation: twinkle 3.8s linear infinite;
}

/* tiny twinkle to hint city lights (complements node glow in CSS) */
@keyframes twinkle{
  0%,100%{ filter:brightness(0.95) saturate(1); transform: translateY(0); }
  50%{ filter:brightness(1.25) saturate(1.15); transform: translateY(-1px); }
}

/* responsive minor adjustments */
@media (max-width:720px){
  .howto-panel{ width: 92vw; left: 50%; top: calc(50% + 150px); transform: translateX(-50%); padding:10px; }
  .howto-title{ font-size:14px; }
}
</style>

<script>
/* How-to panel behavior (show/hide + session hide toggle) */
/* Matches placement and behavior pattern used for other panels in index.html. */
(function(){
  const panel = document.getElementById('howtoPanel');
  const closeBtn = document.getElementById('howtoClose');
  const hideBtn = document.getElementById('howtoHide');
  const showAgain = document.getElementById('howtoShowAgain');

  if(!panel) return;

  // Close permanently (remove from DOM)
  closeBtn.onclick = () => panel.remove();

  // Hide for this session
  hideBtn.onclick = () => {
    panel.style.display = 'none';
    sessionStorage.setItem('howtoHidden', '1');
    showAgain.style.display = 'inline-block';
  };

  // optional small link to restore in the same area (keeps DOM uncluttered)
  showAgain.onclick = () => {
    panel.style.display = '';
    sessionStorage.removeItem('howtoHidden');
    showAgain.style.display = 'none';
  };

  // If previously hidden, keep hidden until session end
  if(sessionStorage.getItem('howtoHidden') === '1'){
    panel.style.display = 'none';
    showAgain.style.display = 'inline-block';
  }
})();
</script>
<!-- ğŸ² Dice script -->
<script src="dice3d.js"></script>
<script>
  Dice3D.init(document.getElementById("map"));
</script>

<!-- ğŸ” Hide floating sign-in after Start -->
<script>
  document.getElementById("startBtn").addEventListener("click", () => {
    const loginPanel = document.getElementById("loginPanel");
    const afterStartPanel = document.getElementById("afterStartPanel");
    setTimeout(() => {
      loginPanel.classList.add("hidden-panel");
      afterStartPanel.classList.remove("hidden-panel");
    }, 600);
  });
  document.getElementById("resetBtn2").onclick = () => location.reload();
</script>

<!-- ğŸµ Music Control Script -->
<script>
  const musicBtn = document.getElementById("musicBtn");
  const bgMusic = document.getElementById("bgMusic");
  let musicPlaying = false;

  musicBtn.onclick = () => {
    if (!musicPlaying) {
      bgMusic.play();
      musicBtn.textContent = "ğŸ”‡ Mute Music";
    } else {
      bgMusic.pause();
      musicBtn.textContent = "ğŸµ Play Music";
    }
    musicPlaying = !musicPlaying;
  };
</script>


<!-- Ø¨Ø§Ù‚ÙŠ Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„Ù„Ø¹Ø¨Ø© ÙŠØ¨Ø¯Ø£ Ù‡Ù†Ø§ -->
<script>
/* =========================================
   MODULE 1: Game State
   ========================================= */

const GameState = {
  towns: ["Tianlu","Ozon","Daruk","Samurai","Turkhan","Marzban","Seraphis","Tsafir","Nimar","Valon","Zemara","Artava","Azharan","Qashim","Liavera","Oravan","Novar","Shariza","Gate of Dusk"],
  prices: [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100],
  players: [],
  activeIndex: 0,
  currentTown: 9,
  started: false,
  palette: ["#ff4d4d","#34c759","#007aff","#ff9500","#af52de","#5ac8fa"],
  locked: false // â† Ø¹Ù†Ø¯Ù…Ø§ true ØªÙ…Ù†Ø¹ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„Ø¹Ø¨ Ù…Ù† Ø¥Ø¸Ù‡Ø§Ø± Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙØ§Ø¹Ù„
};

/* =========================================
   MODULE 2: UI
   ========================================= */
const UI = {
  map: document.getElementById("map"),
  logBox: document.getElementById("log"),
  townText: document.getElementById("currentTownText"),
  greenDie: document.getElementById("greenDie"),
  redDie: document.getElementById("redDie"),
  turnBanner: document.getElementById("turnBanner"),

  log(msg) {
    const div = document.createElement("div");
    div.textContent = msg;
    this.logBox.prepend(div);

    // ğŸ”” Floating notification
    if (typeof Notifications !== "undefined") {
      Notifications.show(msg);
    }
  },

  updateTown() {
    const i = GameState.currentTown;
    const townName = GameState.towns[i];
    const price = GameState.prices[i];

    this.townText.innerHTML = `
        
      <span class="town-name">${townName}</span> City &nbsp;&nbsp;
      <br>ğŸª price <br> 
      <span class="price-flash">$${price}</span>
    `;

    document.querySelectorAll(".node").forEach(n => n.classList.remove("town-current"));
    const node = document.querySelector(`.node[data-index="${i}"]`);
    if (node) node.classList.add("town-current");
  },

townCoords: [
  [52, 93],//1
  [47, 90],//2
  [46, 85],//3
  [53, 80],//4
  [60, 76],//5
  [57, 70],//6
  [53, 65],//7
  [50, 60],//8
  [49, 53],//9
  [40, 48],//10
  [50, 45],//20
  [47, 40],//30
  [44, 35],//40
  [45, 29],//50
  [53, 25],//60
  [47, 21],//70
  [48, 16],//80
  [47, 12], //90
  [48, 9], //100
],

  createNode(index, name, price) {
    const div = document.createElement("div");
    div.className = "node";
    div.dataset.index = index;
    div.innerHTML = `
      <div class="price-main">$${price}</div>
      <div class="town-small">${name}</div>
    `;

    // Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
    if (this.townCoords && this.townCoords[index]) {
      let [x, y] = this.townCoords[index];
      x = Math.max(0, Math.min(100, x));
      y = Math.max(0, Math.min(100, y));
      div.style.left = x + "%";
      div.style.top = y + "%";
    }

    div.style.position = "absolute";
    div.style.zIndex = 10;
    this.map.appendChild(div);
  },

refreshTable() {
  const container = document.querySelector("#map");
  if (!container) return;
  container.querySelectorAll(".player-card").forEach(el => el.remove());

  GameState.players.forEach((p, i) => {
    const avg = p.camels ? (p.totalSpent / p.camels).toFixed(1) : "-";
    const wealth = (p.gold + p.camels * GameState.prices[GameState.currentTown]).toFixed(1);

    const card = document.createElement("div");
    card.className = "player-card";
    if (i === GameState.activeIndex) card.classList.add("active");

card.style.borderColor = p.color;
card.style.background = `${p.color}15`;
card.style.color = p.color;

card.style.position = "absolute";
card.style.zIndex = 2500;

const CARD_SCALE = 1.1;
card.style.width = (26 * CARD_SCALE) + "%";
card.style.maxWidth = Math.round(160 * CARD_SCALE) + "px";
card.style.fontSize = Math.round(11 * CARD_SCALE) + "px";

card.style.opacity = "0.95";
card.style.backdropFilter = "blur(4px)";
card.style.borderRadius = "10px";
card.style.transition = "all 0.3s ease";

/* ğŸ¯ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ¶Ø¹ ÙƒÙ„ ÙƒØ§Ø±Øª Ù„Ø§Ø¹Ø¨ Ø¨Ø´ÙƒÙ„ ÙŠØ¯ÙˆÙŠ */
switch (i) {
  
	case 0: // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø§ÙˆÙ„
    card.style.left = "0%";
    card.style.bottom = "10%";
    break;
	
	case 1: // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø«Ø§Ù†ÙŠ
    card.style.right = "0%";
    card.style.bottom = "10%";
    break;
	
	case 2: // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø«Ø§Ù„Ø«
    card.style.left = "0%";
    card.style.top = "4%";
    break;
	
	case 3: // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø±Ø§Ø¨Ø¹
    card.style.right = "0%";
    card.style.top = "4%";
    break;
	
	
	default: // Ø£ÙŠ Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø¥Ø¶Ø§ÙÙŠÙŠÙ†
    card.style.left = `${10 + i * 0}%`;
    card.style.bottom = "4%";
    break;
}
	card.innerHTML = `
      <div class="player-header">
        <div>
          <span class="player-dot-inline" style="background:${p.color}"></span>
          ${p.name} ${p.isAI ? "ğŸ¤–" : "ğŸ§"}
        </div>
        <div class="turn-status">${i === GameState.activeIndex ? "ğŸ¯ Your Turn" : ""}</div>
      </div>

      <hr class="player-divider" />

      <div class="player-info-grid">
        <div><span class="icon">ğŸª</span> <strong>${p.camels}</strong> Camels</div>
        <div><span class="icon">ğŸ’²</span> <strong>${p.gold}</strong> Gold</div>
      </div>
    `;

    // âœ… If it's this player's turn and not AI, show trade buttons â€” BUT ONLY if game not locked
    if (i === GameState.activeIndex && !p.isAI && GameState.started && !GameState.locked) {
      const btnArea = document.createElement("div");
      btnArea.className = "inline-buttons";

      btnArea.innerHTML = `
   <input type="number" id="inlineCamelCount" value="1" min="1" />

  <div class="top-row">
    <button class="inline-buy">Buy ğŸª</button>
    <button class="inline-sell">Sell ğŸ’°</button>
  </div>

  <div class="bottom-row">
    <button class="inline-wait">Wait â³</button>
  </div>
  
`;

	  	  	  	  

      card.appendChild(btnArea);

      // connect functionality
      const buy = btnArea.querySelector(".inline-buy");
      const sell = btnArea.querySelector(".inline-sell");
      const wait = btnArea.querySelector(".inline-wait");
      const countInput = btnArea.querySelector("#inlineCamelCount");

      const price = GameState.prices[GameState.currentTown];
      buy.disabled = (p.gold < price);
      sell.disabled = (p.camels <= 0);

      buy.onclick = () => {
        const n = +countInput.value;
        PlayerActions.buy(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      sell.onclick = () => {
        const n = +countInput.value;
        PlayerActions.sell(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      wait.onclick = () => {
        UI.log(`${p.name} waits.`);
        SoundFX.wait(); // ğŸ”Š Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        GameFlow.playerActed();
      };
    } else if (i === GameState.activeIndex && !p.isAI && GameState.locked) {
      // Show a subtle "busy" hint instead of interactive buttons
      const hint = document.createElement("div");
      hint.className = "inline-buttons";
      hint.style.opacity = 0.8;
      hint.innerHTML = `<div style="padding:6px 10px; font-size:13px;">â³ Waiting for caravan...</div>`;
      card.appendChild(hint);
    }

    container.appendChild(card);
  });
},

highlightActivePlayer() {
  const active = GameState.players[GameState.activeIndex];
  this.turnBanner.textContent = `ğŸ¯ ${active.name}'s Turn ${active.isAI ? "(AI)" : ""}`;

  GameState.players.forEach((p, i) =>
    p.dotEl.classList.toggle("active", i === GameState.activeIndex)
  );

  const cards = document.querySelectorAll(".player-card");
  cards.forEach((card, i) => {
    card.classList.toggle("active", i === GameState.activeIndex);
  });
}
}; // âœ… Ø¥ØºÙ„Ø§Ù‚ ÙƒØ§Ø¦Ù† UI Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø³Ù„ÙŠÙ…
/* =========================================
   MODULE 3: Player Actions
   ========================================= */
const PlayerActions = {
  buy(p, n) {
    const price = GameState.prices[GameState.currentTown];
    if (p.gold < price * n) return UI.log(`${p.name} can't afford that.`);
    p.gold -= price * n;
    p.camels += n;
    p.totalSpent += price * n;
    UI.log(`${p.name} bought ${n} camels at $${price}`);
    SoundFX.buy(); // ğŸ”Š Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø´Ø±Ø§Ø¡
  },

  sell(p, n) {
    const price = GameState.prices[GameState.currentTown];
    if (p.camels < n) return UI.log(`${p.name} has not enough camels.`);
    const avg = p.camels ? (p.totalSpent / p.camels) : 0;
    p.camels -= n;
    p.gold += price * n;
    p.totalSpent -= avg * n;
    UI.log(`${p.name} sold ${n} camels at $${price}`);
    SoundFX.sell(); // ğŸ”Š Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¨ÙŠØ¹
  }
};

/* =========================================
   MODULE 4: Game Flow â€” Round-based & synchronized dice
   - Ensures dice work from the very first roll
   - Ignores double numbers (1â€“1, 2â€“2, etc.)
   ========================================= */
const GameFlow = (function () {
  let actionsTaken = 0;
  let roundNumber = 1;

  async function rollValidDice() {
    try {
      GameState.locked = true;
      UI.refreshTable();

      const { green, red } = await rollDiceWithPromise();
      await processDiceResults(green, red);
    } catch (err) {
      console.error("rollValidDice error:", err);
      UI.log("âš ï¸ Dice error â€” fallback random rolls used.");
      await processDiceResults(random1to6(), random1to6());
    } finally {
      GameState.locked = false;
      UI.refreshTable();
    }
  }

/* ====================================================
   FIXED: Roll both dice (3D only) with safe single resolve
   ==================================================== */
function rollDiceWithPromise() {
  return new Promise((resolve) => {
    let resolved = false;

    // âœ… ÙŠÙ…Ù†Ø¹ ØªÙƒØ±Ø§Ø± Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù…Ø±ØªÙŠÙ†
    const safeResolve = (res) => {
      if (resolved) return;
      resolved = true;
      resolve(res);
    };

    // Ø¹Ù†Ø¯Ù…Ø§ ØªÙ†ØªÙ‡ÙŠ Ø­Ø±ÙƒØ© Ø§Ù„Ø²Ù‡Ø± Ø§Ù„Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    Dice3D.onRollDone(({ green, red }) => safeResolve({ green, red }));

    // Ø§Ø¨Ø¯Ø£ Ù„Ù Ø§Ù„Ø²Ù‡Ø± Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    const result = Dice3D.rollBoth({
  currentTownIndex: GameState.currentTown,
  townsCount: GameState.towns.length
});

    // ğŸ”Š Ø´ØºÙ‘Ù„ Ø§Ù„ØµÙˆØª Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù„Ù
    try { if (typeof SoundFX !== "undefined") SoundFX.diceRoll(); } catch (e) {}

    // â±ï¸ ÙÙŠ Ø­Ø§Ù„Ø© Ù„Ù… ÙŠØ±Ø³Ù„ Dice3D Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ø£ÙŠ Ø³Ø¨Ø¨ØŒ Ø§Ø³ØªØ®Ø¯Ù… fallback Ø¨Ø¹Ø¯ 1.6 Ø«Ø§Ù†ÙŠØ©
    setTimeout(() => safeResolve(result), 1600);
  });
}

  function random1to6() {
    return Math.floor(Math.random() * 6) + 1;
  }

  async function processDiceResults(g, r) {
    UI.greenDie.textContent = g;
    UI.redDie.textContent = r;
    UI.greenDie.classList.add("roll");
    UI.redDie.classList.add("roll");
    setTimeout(() => {
      UI.greenDie.classList.remove("roll");
      UI.redDie.classList.remove("roll");
    }, 600);

    const currentPrice = GameState.prices[GameState.currentTown];
    let usedGreen = true, usedRed = true;

    if (currentPrice === 1) {
      usedRed = false;
      UI.log("â„¹ï¸ Bottom city: ignoring RED die.");
    } else if (currentPrice === 100) {
      usedGreen = false;
      UI.log("â„¹ï¸ Top city: ignoring GREEN die.");
    }

    let diff = 0;
    let direction = "none";

    if (usedGreen && !usedRed) {
      diff = g;
      direction = "green-only";
    } else if (!usedGreen && usedRed) {
      diff = r;
      direction = "red-only";
    } else if (usedGreen && usedRed) {
      if (g > r) { diff = g - r; direction = "up"; }
      else if (r > g) { diff = r - g; direction = "down"; }
    }

    const msg = `ğŸ² Dice: Green ${g} | Red ${r} â†’ ${direction.toUpperCase()} ${diff}`;
    UI.log(msg);
    if (typeof Notifications !== "undefined")
      Notifications.show(msg, { level: "important", duration: 2000, sound: false });

    if (diff <= 0) {
      UI.log("ğŸª Caravan stays in place this round.");
      UI.updateTown();
      UI.refreshTable();
      positionPlayers();
      UI.highlightActivePlayer();
      await new Promise(res => setTimeout(res, 300));
      return;
    }

    GameState.locked = true;
    UI.refreshTable();

    const prevIndex = GameState.currentTown;
    let newIndex = prevIndex;

    if (direction === "green-only" || direction === "up")
      newIndex = Math.min(GameState.towns.length - 1, prevIndex + diff);
    else if (direction === "red-only" || direction === "down")
      newIndex = Math.max(0, prevIndex - diff);

    GameState.currentTown = newIndex;
    const newTown = GameState.towns[newIndex];
    const newPrice = GameState.prices[newIndex];

    UI.log(`ğŸª Caravan moved to ${newTown} â€” Price $${newPrice}`);
    try { if (typeof SoundFX !== "undefined") SoundFX.caravanMove(); } catch(e){}

    UI.updateTown();
    UI.refreshTable();
    positionPlayers();

    await new Promise(res => setTimeout(res, 1100));

    UI.highlightActivePlayer();
    GameState.locked = false;
    UI.refreshTable();
  }

  window.processDiceResults = processDiceResults;

  return {
playerActed() {
  GameState.locked = true;
  UI.refreshTable();

  actionsTaken++;
  UI.log(`âœ… Action registered (${actionsTaken}/${GameState.players.length})`);

  if (actionsTaken >= GameState.players.length) {
    actionsTaken = 0;
    roundNumber++;
    UI.log(`ğŸ”” All players acted â€” rolling dice for round ${roundNumber}`);

    setTimeout(() => {
      GameState.activeIndex = 0;
      UI.highlightActivePlayer();
      UI.refreshTable();
      GameState.locked = false;
      rollValidDice();
    }, 900);
    return;
  }

  const soundDelay = 1100;
  setTimeout(() => {
    this.advanceActivePlayer();
    GameState.locked = false;
    UI.refreshTable();
  }, soundDelay);
},

    advanceActivePlayer() {
  GameState.activeIndex = (GameState.activeIndex + 1) % GameState.players.length;
  UI.refreshTable();
  UI.highlightActivePlayer();

  // ğŸª¶ Ø·ÙŠØ±Ø§Ù† ÙƒØ§Ø±Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù†Ø´Ø· Ø¨Ø¹Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø¯ÙˆØ±
  const activeCard = document.querySelector(".player-card.active");
  if (activeCard && !GameState.locked && GameState.started) {
    activeCard.classList.add("flying");
    setTimeout(() => activeCard.classList.remove("flying"), 1600);
  }

  const current = GameState.players[GameState.activeIndex];
  SoundFX.nextTurn();
  if (current && current.isAI) aiTakeTurn(current);
},

    getRoundNumber() { return roundNumber; },
    resetRound() { actionsTaken = 0; UI.log("ğŸ” Round counters reset."); }
  };
})();

/* =========================================
   MODULE 5: Setup and Event Handlers
   ========================================= */
function init(){
	window.addEventListener("click", () => {
  if (typeof SoundFX !== "undefined" && SoundFX && SoundFX.ctx && SoundFX.ctx.state === "suspended") {
    SoundFX.ctx.resume().catch(()=>{});
  }
}, { once: true });
  GameState.towns.forEach((t,i)=>UI.createNode(i,t,GameState.prices[i]));
  UI.updateTown();
  UI.log("âœ… Ready");
}

function addPlayer(name, isAI = false) {
  // âš™ï¸ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒØªØ¨ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ø³Ù…Ù‹Ø§ØŒ ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ø³Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠ
if (!name || name.trim() === "") {
  const playerNumber = GameState.players.length + 1;
  name = `Player ${playerNumber}`;
}
  const color = GameState.palette[GameState.players.length % GameState.palette.length];
  const p = {
    name,
    gold: 10,
    camels: 0,
    totalSpent: 0,
    isAI,
    color, // âœ… store color for table use
    dotEl: document.createElement("div")
  };

  p.dotEl.className = "player-dot";
  p.dotEl.style.background = color;
  p.dotEl.style.color = color; // ğŸ†• added line for glowing in player color

  GameState.players.push(p);
  UI.map.appendChild(p.dotEl);

  positionPlayers();
  UI.refreshTable();
  UI.log(`${name} joined ${isAI ? "(AI)" : ""}`);
}

function positionPlayers() {
  const node = document.querySelector(`.node[data-index="${GameState.currentTown}"]`);
  if (!node) return;

  // âš™ï¸ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
  const nodeRect = node.getBoundingClientRect();
  const mapRect = UI.map.getBoundingClientRect();
  const centerX = nodeRect.left - mapRect.left + nodeRect.width / 2;
  const centerY = nodeRect.top - mapRect.top + nodeRect.height / 2;

  const total = GameState.players.length;
  if (total === 0) return;

  // ğŸŸ¡ Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø± â€” Ø®Ø§Ø±Ø¬ Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù‚Ù„ÙŠÙ„Ø§Ù‹
  // Ø²ÙŠØ¯ Ø§Ù„Ø±Ù‚Ù… 1.4 Ù„Ø¬Ø¹Ù„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø£Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„Ø§Ù‹ (ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§ Ø­Ø³Ø¨ Ø§Ù„Ø°ÙˆÙ‚)
  const radius = nodeRect.width * 0.7;

  // ğŸ¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ø±ÙŠ Ø­ÙˆÙ„ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
  GameState.players.forEach((p, i) => {
    const angle = (i / total) * 2 * Math.PI; // Ø²Ø§ÙˆÙŠØ© ÙƒÙ„ Ù„Ø§Ø¹Ø¨
    const offsetX = radius * Math.cos(angle);
    const offsetY = radius * Math.sin(angle);

    p.dotEl.style.left = `${centerX + offsetX}px`;
    p.dotEl.style.top = `${centerY + offsetY}px`;
  });
}

document.getElementById("addPlayerBtn").onclick=()=>{
  addPlayer(document.getElementById("newPlayerName").value,false);
  document.getElementById("newPlayerName").value="";
};
document.getElementById("addAIPlayerBtn").onclick=()=>{
  addPlayer("Robot"+(GameState.players.length+1),true);
};

document.getElementById("startBtn").onclick = () => {
  if (GameState.players.length === 0) return UI.log("Add players first!");
  GameState.started = true;
  UI.log("ğŸ® Game started!");
  UI.highlightActivePlayer();
  UI.refreshTable();

  // ğŸš€ If first player is AI, start its turn automatically
  const first = GameState.players[GameState.activeIndex];
  if (first.isAI) aiTakeTurn(first);
};

document.getElementById("resetBtn").onclick=()=>location.reload();

/* =========================================
   MODULE 6: AI Trader Pro ğŸ¤–ğŸ’° (SMART VERSION)
   - Waits 2s before decision
   - Groups all robot logs into one elegant notification
   - Caravan moves only after all players finish
   ========================================= */
function aiTakeTurn(p) {
  // ğŸ§  Start thinking phase
  UI.log(`ğŸ¤– ${p.name} is analyzing market trends... (thinking...)`);
  Notifications.aiLog(`ğŸ¤– ${p.name} is analyzing market trends...`);

  setTimeout(() => {
    const price = GameState.prices[GameState.currentTown];
    const townName = GameState.towns[GameState.currentTown];

    // ğŸ—ºï¸ Log AIâ€™s situational awareness
    if (typeof lastMovedTown === "undefined") {
      UI.log(`ğŸ¤– ${p.name} starts analysis at ${townName}.`);
      Notifications.aiLog(`ğŸ“ Starting analysis in ${townName}.`);
    } else if (lastMovedTown === GameState.currentTown) {
      UI.log(`ğŸ¤– ${p.name} notices caravan still in ${townName}.`);
      Notifications.aiLog(`ğŸ“ Caravan still in ${townName}.`);
    }

    lastMovedTown = GameState.currentTown;

    const gold = p.gold;
    const camels = p.camels;

    // ğŸª Buying strategy
    if (price < 10 && gold >= price) {
      const budgetFactor = (10 - price) / 10;
      let spendAmount = gold * budgetFactor;
      if (price === 1) spendAmount = gold * 0.95;
      const n = Math.max(1, Math.floor(spendAmount / price));

      PlayerActions.buy(p, n);
      UI.log(`ğŸ¤– ${p.name} found a cheap market ($${price}) and bought ${n} camels.`);
      Notifications.aiLog(`ğŸŸ¢ Cheap market ($${price}) â€” bought ${n} camels.`);
    }

    // ğŸ’° Selling strategy
    else if (price >= 70 && camels > 0) {
      const avg = camels ? (p.totalSpent / camels) : 0;
      const profitRatio = price / (avg || 1);
      let n = 0;

      if (price >= 90) {
        n = camels;
        PlayerActions.sell(p, n);
        UI.log(`ğŸ¤– ${p.name} sees premium prices! Selling ALL camels at $${price}.`);
        Notifications.aiLog(`ğŸ’ Premium market ($${price}) â€” sold ALL ${n} camels.`);
      } else if (profitRatio >= 1.2) {
        n = Math.ceil(camels * 0.6);
        PlayerActions.sell(p, n);
        UI.log(`ğŸ¤– ${p.name} takes profits and sells ${n} camels at $${price}.`);
        Notifications.aiLog(`ğŸ’° Profitable market â€” sold ${n} camels.`);
      } else {
        n = Math.ceil(camels * 0.3);
        PlayerActions.sell(p, n);
        UI.log(`ğŸ¤– ${p.name} sells ${n} camels cautiously at $${price}.`);
        Notifications.aiLog(`âš–ï¸ Mild profit â€” sold ${n} camels cautiously.`);
      }
    }

    // ğŸ¤” Waiting strategy
    else {
      UI.log(`ğŸ¤– ${p.name} decides to WAIT for a better opportunity.`);
      Notifications.aiLog(`â³ Waits for better prices.`);
    }

    // âœ… Finalize AI summary
    Notifications.aiLog("", true);

    // ğŸ§¾ Refresh player info and proceed to next turn

UI.refreshTable();
GameFlow.playerActed();   // âœ… ÙŠØ³Ø¬Ù‘Ù„ Ø§Ù„ÙØ¹Ù„ Ø¨Ø¯Ù„ Ù…Ø§ ÙŠØ¨Ø¯Ù‘Ù„ Ø§Ù„Ø¯ÙˆØ± ÙÙˆØ±Ù‹Ø§
  }, 4000);
}

/* =========================================
   MODULE 7: Smart Single-Line Notifications (Map)
   ========================================= */
const Notifications = (function () {
  let el = null;
  let aiBuffer = "";
  let showing = false;
  let hideTimer = null;

  // ğŸ§± Ensure notification element exists
  function ensure() {
    if (el) return;
    el = document.createElement("div");
    el.id = "smart-notif";
    el.setAttribute("role", "status");
    el.setAttribute("aria-live", "polite");
    el.style.pointerEvents = "none";

    // Attach inside the map (or fallback to body)
    const map = document.querySelector(".map");
    if (map) map.appendChild(el);
    else document.body.appendChild(el);

    // ğŸ’… Shimmer style
    const s = document.createElement("style");
    s.textContent = `
#smart-notif {
  position: absolute;
  bottom: 5px;
  left: 10px;
  z-index: 1000;
  pointer-events: none;
  font-family: system-ui, sans-serif;
  font-weight: 500;
  font-size: 14px;
  letter-spacing: 0.4px;
  white-space: nowrap;
  text-align: left;
  opacity: 0;
  -webkit-font-smoothing: antialiased;

  background: linear-gradient(90deg, #ffffff, #ffd166, #7be57b, #ffffff);
  background-size: 300%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: hueShift 6s linear infinite;

  transition: opacity 0.35s ease, transform 0.35s ease;
  text-shadow: 0 2px 10px rgba(0,0,0,0.45);
}

#smart-notif.visible {
  opacity: 1;
  transform: translateY(-6px);
}

#smart-notif:not(.visible) {
  transform: translateY(10px);
}

@keyframes hueShift {
  0%   { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}`;
    document.head.appendChild(s);
  }

function playChime() {
  try {
    if (typeof SoundFX !== "undefined") {
      // âŒ Ù„Ø§ Ù†Ø³ØªØ®Ø¯Ù… ØµÙˆØª Ø§Ù„Ù†Ø±Ø¯ Ù‡Ù†Ø§ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
      // âœ… Ø§Ø³ØªØ®Ø¯Ù… ØµÙˆØª Ø¥Ø´Ø¹Ø§Ø± Ø¹Ø§Ù… Ù…Ù†ÙØµÙ„
      if (typeof SoundFX.notify === "function") SoundFX.notify();
      else if (typeof SoundFX.wait === "function") SoundFX.wait();
    }
  } catch (e) { /* silent fail */ }
}

  // ğŸ§  Smart Replace Notification System
  function show(msg, opts = {}) {
    ensure();
    if (!msg) return;

    const level = opts.level || "info";
    const duration = opts.duration || (level === "important" ? 4200 : 2500);
    const sound = opts.sound ?? (level === "important");

    // If already showing â†’ fade out first, then show new
    if (showing) {
      el.classList.remove("visible");
      clearTimeout(hideTimer);
      setTimeout(() => displayNow(msg, duration, sound), 200);
    } else {
      displayNow(msg, duration, sound);
    }
  }

  function displayNow(msg, duration, sound) {
    showing = true;
    el.textContent = msg;
    el.classList.add("visible");
    if (sound) playChime();

    hideTimer = setTimeout(() => {
      el.classList.remove("visible");
      setTimeout(() => {
        el.textContent = "";
        showing = false;
      }, 300);
    }, duration);
  }

  // ğŸ¤– AI message grouping (summarized)
  function aiLog(line, done = false) {
    if (line && line.trim()) {
      if (aiBuffer) aiBuffer += " Â· ";
      aiBuffer += line.trim().replace(/\s+/g, " ");
      if (aiBuffer.length > 160) aiBuffer = aiBuffer.slice(0, 157) + "â€¦";
    }
    if (done && aiBuffer) {
      show(aiBuffer, { level: "good", duration: 5200 });
      aiBuffer = "";
    }
  }

  return { show, aiLog };
})();

/* =========================================
   MODULE 8: Dynamic Map + Sidebar Resizer & Audio Lifecycle
   - Replaces the previous resizer module entirely
   - Responsibilities:
     * Responsive scaling for dice (use map width as base)
     * Responsive adjustments for #musicCtl and .sidebar
     * Positioning fix for player dots (percentage â†’ px recalculation)
     * Pause/stop audio on page hide/unload
   ========================================= */
(function () {
  const container = document.querySelector(".container");
  const mapEl = document.querySelector(".map");
  const musicCtl = document.getElementById("musicCtl");
  const bgMusic = document.getElementById("bgMusic");
  let resizeTimer = null;

  if (!mapEl) return;

  // --- PARAMETERS (tweakable)
  const DICE_MAP_RATIO = 0.08; // dice max width = mapWidth * DICE_MAP_RATIO (8%)
  const DICE_MIN_PX = 28;
  const DICE_MAX_PX = 120;
  const SIDEBAR_MOBILE_BREAK = 720; // px -> below this, collapse sidebar

  // Ensure player dots and nodes use map-relative coordinates on resize/initial
  function recalcPlayerPositions() {
    const node = document.querySelector(`.node[data-index="${GameState.currentTown}"]`);
    if (!node) return;
    const nodeRect = node.getBoundingClientRect();
    const mapRect = mapEl.getBoundingClientRect();
    const centerX = nodeRect.left - mapRect.left + nodeRect.width / 2;
    const centerY = nodeRect.top - mapRect.top + nodeRect.height / 2;

    const total = GameState.players.length;
    const townRadius = Math.max(nodeRect.width, nodeRect.height) / 2;
    const radius = Math.max(8, Math.round(townRadius * 0.8)); // scale radius with town size

    GameState.players.forEach((p, i) => {
      // distribute around circle but keep within map
      let x = centerX;
      let y = centerY;
      if (total > 1) {
        const angle = (i / total) * 2 * Math.PI;
        x += radius * Math.cos(angle);
        y += radius * Math.sin(angle);
      }
      // set in px but keep translate(-50%,-50%) in CSS so left/top point to center
      p.dotEl.style.left = `${x}px`;
      p.dotEl.style.top = `${y}px`;
    });
  }

  // Scale 3D dice wrappers that Dice3D created
  function scaleDiceToMap() {
    const containerDice = document.getElementById("dice3d-container");
    if (!containerDice) return;

    const mapRect = mapEl.getBoundingClientRect();
    const mapWidth = Math.max(180, mapRect.width); // safe fallback

    // compute desired dice size in px bounded by min/max
    const desired = Math.round(mapWidth * DICE_MAP_RATIO);
    const size = Math.max(DICE_MIN_PX, Math.min(DICE_MAX_PX, desired));

    // apply to each wrapper (created by dice3d.createDie)
    const wrappers = containerDice.querySelectorAll(".dice3d-wrapper");
    wrappers.forEach(w => {
      w.style.width = `${size}px`;
      w.style.height = `${size}px`;
      // update perspective for nicer 3d on small dice
      w.style.perspective = `${Math.max(400, size * 8)}px`;
      // update child faces' borderRadius if present
      const faces = w.querySelectorAll(".dice3d-face");
      faces.forEach(f => {
        f.style.borderRadius = Math.max(6, Math.round(size * 0.12)) + "px";
      });
      // if wrapper keeps a cached _diceSize, update it
      if (w._diceSize) w._diceSize = size;
    });

    // also scale the simple .die (numeric readouts) to not overlap
    const numericDice = document.querySelectorAll(".die");
    numericDice.forEach((d, idx) => {
      d.style.width = `${Math.round(size * 0.9)}px`;
      d.style.height = `${Math.round(size * 0.9)}px`;
      d.style.lineHeight = `${Math.round(size * 0.9)}px`;
      d.style.fontSize = `${Math.max(14, Math.round(size * 0.45))}px`;
      // ensure bottom placement stays reasonable on small screens
      const bottomOffset = Math.min(16, Math.round(size * 0.12));
      d.style.bottom = `${bottomOffset}px`;
    });
  }

function adjustMusicCtl() {
  if (!musicCtl) return;
  // Ø§Ù„Ø¢Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ Ø§Ù„Ù€ sidebarØŒ Ù„Ø§ ÙŠØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù‚ÙŠØ§Ø³Ø§Øª mapRect
  const sidebar = document.querySelector(".sidebar");
  if (!sidebar) return;

  const sidebarWidth = sidebar.getBoundingClientRect().width;
  if (sidebarWidth < 300) {
    musicCtl.classList.add("compact-music");
  } else {
    musicCtl.classList.remove("compact-music");
  }
}

  // Responsive sidebar: collapse/hide on small screens (so map remains primary)
  function adjustSidebar() {
    const sidebar = document.querySelector(".sidebar");
    if (!sidebar) return;
    const mapRect = mapEl.getBoundingClientRect();
    if (mapRect.width < SIDEBAR_MOBILE_BREAK) {
  sidebar.style.width = "90vw";
      sidebar.style.opacity = "0.95";
      sidebar.style.position = "absolute";
      sidebar.style.right = "10px";
      sidebar.style.top = "10px";
      sidebar.style.maxHeight = "48%";
      sidebar.style.overflow = "auto";
      sidebar.classList.add("sidebar-collapsed");
    } else {
      // restore defaults â€“ keep CSS-driven if possible
      sidebar.style.width = "";
      sidebar.style.position = "";
      sidebar.style.right = "";
      sidebar.style.top = "";
      sidebar.style.maxHeight = "";
      sidebar.classList.remove("sidebar-collapsed");
    }
  }

  // Pause/suspend background audio & sound context on visibility change or unload
  function ensureAudioLifecycle() {
    // when page hidden -> pause audio & suspend AudioContext
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        if (bgMusic && !bgMusic.paused) {
          try { bgMusic.pause(); } catch (e) {}
        }
        if (SoundFX && SoundFX.ctx && SoundFX.ctx.state === "running") {
          try { SoundFX.ctx.suspend().catch(()=>{}); } catch(e) {}
        }
      } else {
        // when user returns, keep audio paused (to avoid autoplay); optionally show a small hint
        // do not auto-play without explicit gesture
      }
    });

    // on unload: stop background audio immediately
    window.addEventListener("pagehide", () => { // pagehide works well on mobile
      try {
        if (bgMusic) {
          bgMusic.pause();
          bgMusic.currentTime = 0;
        }
        if (SoundFX && SoundFX.ctx) {
          // close or suspend if available
          if (SoundFX.ctx.close) SoundFX.ctx.close().catch(()=>{});
          else if (SoundFX.ctx.suspend) SoundFX.ctx.suspend().catch(()=>{});
        }
      } catch (e) { /* silent */ }
    });

    // also handle beforeunload for older browsers
    window.addEventListener("beforeunload", () => {
      try {
        if (bgMusic) {
          bgMusic.pause();
          bgMusic.currentTime = 0;
        }
      } catch (e) {}
    });
  }

  // Single adjustment entrypoint (debounced)
  function adjustAll() {
    // guard: map must have layout
    if (!mapEl) return;
    scaleDiceToMap();
    recalcPlayerPositions();
    adjustMusicCtl();
    adjustSidebar();
  }

  // Debounced resize to avoid thrashing
  function onResize() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      adjustAll();
    }, 120);
  }

  // Initial run and binding
  window.addEventListener("resize", onResize);
  // Also react to orientationchange on mobile
  window.addEventListener("orientationchange", onResize);

  // Run initial adjustments after small delay to allow DOM layout
  setTimeout(() => {
    adjustAll();
    ensureAudioLifecycle();
  }, 120);

  // Expose a manual hook for debugging/tests
  window.UI_adjustModule8 = adjustAll;
  window.UI_recalcPlayers = recalcPlayerPositions;
})();



init();
</script>
<script src="themes.js"></script>
<script src="musicControl.js"></script>
<script src="soundFX.js"></script>
<!-- ğŸ“ Zoom Control -->
<div id="zoomControl">
  <input type="range" id="zoomSlider" min="50" max="120" value="100" />
</div>

<script>
  const zoomSlider = document.getElementById("zoomSlider");
  const zoomControl = document.getElementById("zoomControl");
  let fadeTimeout;

  zoomSlider.addEventListener("input", (e) => {
    const scale = e.target.value / 100;
    document.querySelector(".container").style.transform = `scale(${scale})`;
    document.querySelector(".container").style.transformOrigin = "center top";

    zoomControl.style.opacity = "1";
    clearTimeout(fadeTimeout);

    fadeTimeout = setTimeout(() => {
      zoomControl.style.opacity = "0.4";
    }, 3000);
  });
</script>
</body>
</html>