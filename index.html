
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Grand Silk Road â€” by mO</title>
<link rel="stylesheet" href="silkroad-style.css?v=1.0.0.6">
</head>

<body>

<div class="container">
<div class="map" id="map">
<div id="diceContainer"></div>
<div id="greenDie" class="die"></div>
<div id="redDie" class="die"></div>
</div>

  <div class="sidebar"> 
 </div>
    <div class="panel">

<!-- âœ¨ Floating Sign-In Panel -->
<div class="login-floating" id="loginPanel">
  <h2>ğŸ•ï¸ Caravan Entry</h2>
  <input id="newPlayerName" type="text" placeholder="Player name..." />
  <div class="btns">
    <button id="addPlayerBtn">Add a player</button>
    <button id="addAIPlayerBtn" class="ai">Robot ğŸ¤–</button>
    <button id="startBtn" class="primary"> Start </button>
  </div>
  <button id="resetBtn" class="reset">âŸ³</button>
</div>

<!-- ğŸª„ After Start (Mini Floating Glass Panel) -->
<div class="after-start-floating hidden-panel" id="afterStartPanel">
  <button id="resetBtn2" class="primary">ğŸŒŸ Start a new game</button>
</div>
<script src="dice3d.js"></script>
<script>
  Dice3D.init(document.getElementById("map"));
</script>
<script>
/* ğŸ” Hide floating sign-in after Start */
document.getElementById("startBtn").addEventListener("click", () => {
  const loginPanel = document.getElementById("loginPanel");
  const afterStartPanel = document.getElementById("afterStartPanel");
  setTimeout(() => {
    loginPanel.classList.add("hidden-panel");
    afterStartPanel.classList.remove("hidden-panel");
  }, 600);
});
document.getElementById("resetBtn2").onclick = () => location.reload();
</script>

    <div class="panel">

<br/> <br/> <br/>

      <strong></strong>
<br/> <br/>

      <strong></strong>

      <div id="currentTownText"> ğŸ™ï¸ price: </div><br/>

      <div id="turnBanner">Waiting for players...</div><br/>

    <div class="panel">


      <strong>Players <br/> <br/> </strong>

<div id="playersTableContainer" class="players-container"></div>

    </div>
	
    <div class="panel">
      <strong>Log</strong>

<div id="log"></div>

<div id="ytWrapper" style="display:none; text-align:center; margin-top:10px;">
  <iframe id="ytFrame" width="360" height="215"
    src=""
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
  </iframe>
</div>

    </div>
  </div>
</div>

<script>



/* =========================================
   MODULE 1: Game State
   ========================================= */
const GameState = {
  towns: ["Tianlu","Ozon","Daruk","Samurai","Turkhan","Marzban","Seraphis","Tsafir","Nimar","Valon","Zemara","Artava","Azharan","Qashim","Liavera","Oravan","Novar","Shariza","Gate of Dusk"],
  prices: [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100],
  players: [],
  activeIndex: 0,
  currentTown: 9,
  started: false,
  palette: ["#ff4d4d","#34c759","#007aff","#ff9500","#af52de","#5ac8fa"]
};

/* =========================================
   MODULE 2: UI
   ========================================= */
const UI = {
  map: document.getElementById("map"),
  logBox: document.getElementById("log"),
  townText: document.getElementById("currentTownText"),
  greenDie: document.getElementById("greenDie"),
  redDie: document.getElementById("redDie"),
  turnBanner: document.getElementById("turnBanner"),

  log(msg) {
    const div = document.createElement("div");
    div.textContent = msg;
    this.logBox.prepend(div);

    // ğŸ”” Floating notification
    if (typeof Notifications !== "undefined") {
      Notifications.show(msg);
    }
  },

  updateTown() {
    const i = GameState.currentTown;
    const townName = GameState.towns[i];
    const price = GameState.prices[i];

    this.townText.innerHTML = `
      ğŸ™ï¸ You are in 
      <span class="town-name">${townName}</span> City &nbsp;&nbsp;
      <br>ğŸª Camel price 
      <span class="price-flash">$${price}</span>
    `;

    document.querySelectorAll(".node").forEach(n => n.classList.remove("town-current"));
    const node = document.querySelector(`.node[data-index="${i}"]`);
    if (node) node.classList.add("town-current");
  },

townCoords: [
  [60, 82],  // Tianlu ($1) â€” Bottom
  [55, 78],  // Ozon ($2)
  [50, 74],  // Daruk ($3)
  [45, 70],  // Samurai ($4)
  [40, 66],  // Turkhan ($5)
  [35, 62],  // Marzban ($6)
  [32, 58],  // Seraphis ($7)
  [38, 54],  // Tsafir ($8)
  [44, 50],  // Nimar ($9)
  [50, 46],  // Valon ($10)
  [45, 42],  // Zemara ($20)
  [40, 38],  // Artava ($30)
  [35, 34],  // Azharan ($40)
  [30, 30],  // Qashim ($50)
  [34, 26],  // Liavera ($60)
  [38, 22],  // Oravan ($70)
  [44, 18],  // Novar ($80)
  [50, 14],  // Shariza ($90)
  [56, 10],  // Gate of Dusk ($100) â€” Top
],

  createNode(index, name, price) {
    const div = document.createElement("div");
    div.className = "node";
    div.dataset.index = index;
    div.innerHTML = `
      <div class="price-main">$${price}</div>
      <div class="town-small">${name}</div>
    `;

    // Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
    if (this.townCoords && this.townCoords[index]) {
      let [x, y] = this.townCoords[index];
      x = Math.max(0, Math.min(100, x));
      y = Math.max(0, Math.min(100, y));
      div.style.left = x + "%";
      div.style.top = y + "%";
    }

    div.style.position = "absolute";
    div.style.zIndex = 10;
    this.map.appendChild(div);
  },

refreshTable() {
  const container = document.querySelector("#playersTableContainer");
  if (!container) return;
  container.innerHTML = "";

  GameState.players.forEach((p, i) => {
    const avg = p.camels ? (p.totalSpent / p.camels).toFixed(1) : "-";
    const wealth = (p.gold + p.camels * GameState.prices[GameState.currentTown]).toFixed(1);

    const card = document.createElement("div");
    card.className = "player-card";
    if (i === GameState.activeIndex) card.classList.add("active");

    card.style.borderColor = p.color;
    card.style.background = `${p.color}15`;
    card.style.color = p.color;

    card.innerHTML = `
      <div class="player-header">
        <div>
          <span class="player-dot-inline" style="background:${p.color}"></span>
          ${p.name} ${p.isAI ? "ğŸ¤–" : "ğŸ§"}
        </div>
        <div class="turn-status">${i === GameState.activeIndex ? "ğŸ¯ Your Turn" : ""}</div>
      </div>

      <hr class="player-divider" />

      <div class="player-info-grid">
        <div><span class="icon">ğŸª</span> <strong>${p.camels}</strong> Camels</div>
        <div><span class="icon">ğŸ’²</span> <strong>${p.gold}</strong> Gold</div>
      </div>
    `;

    // âœ… If it's this player's turn and not AI, show trade buttons
    if (i === GameState.activeIndex && !p.isAI && GameState.started) {
      const btnArea = document.createElement("div");
      btnArea.className = "inline-buttons";

      btnArea.innerHTML = `
        <div class="number-input">
          <button class="num-btn minus">â€“</button>
          <input type="number" id="inlineCamelCount" value="1" min="1" />
          <button class="num-btn plus">+</button>
        </div>
        <button class="inline-buy">Buy</button>
        <button class="inline-sell">Sell</button>
        <button class="inline-wait">Wait</button>
      `;

      const input = btnArea.querySelector("#inlineCamelCount");
      btnArea.querySelector(".plus").onclick = () => input.stepUp();
      btnArea.querySelector(".minus").onclick = () => input.stepDown();

      card.appendChild(btnArea);

      // connect functionality
      const buy = btnArea.querySelector(".inline-buy");
      const sell = btnArea.querySelector(".inline-sell");
      const wait = btnArea.querySelector(".inline-wait");
      const countInput = btnArea.querySelector("#inlineCamelCount");

      const price = GameState.prices[GameState.currentTown];
      buy.disabled = (p.gold < price);
      sell.disabled = (p.camels <= 0);

      buy.onclick = () => {
        const n = +countInput.value;
        PlayerActions.buy(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      sell.onclick = () => {
        const n = +countInput.value;
        PlayerActions.sell(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      wait.onclick = () => {
        UI.log(`${p.name} waits.`);
        SoundFX.wait(); // ğŸ”Š Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        GameFlow.playerActed();
      };
    }

    container.appendChild(card);
  });
}, // ğŸ‘ˆ Ù„Ø§Ø­Ø¸ Ø§Ù„ÙØ§ØµÙ„Ø© Ù‡Ù†Ø§ ØµØ­ÙŠØ­Ø© Ù„Ø£Ù†Ù‡Ø§ ØªØºÙ„Ù‚ refreshTable Ø¯Ø§Ø®Ù„ ÙƒØ§Ø¦Ù† UI

highlightActivePlayer() {
  const active = GameState.players[GameState.activeIndex];
  this.turnBanner.textContent = `ğŸ¯ ${active.name}'s Turn ${active.isAI ? "(AI)" : ""}`;

  GameState.players.forEach((p, i) =>
    p.dotEl.classList.toggle("active", i === GameState.activeIndex)
  );

  const cards = document.querySelectorAll(".player-card");
  cards.forEach((card, i) => {
    card.classList.toggle("active", i === GameState.activeIndex);
  });
}
}; // âœ… Ø¥ØºÙ„Ø§Ù‚ ÙƒØ§Ø¦Ù† UI Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø³Ù„ÙŠÙ…
/* =========================================
   MODULE 3: Player Actions
   ========================================= */
const PlayerActions = {
  buy(p, n) {
    const price = GameState.prices[GameState.currentTown];
    if (p.gold < price * n) return UI.log(`${p.name} can't afford that.`);
    p.gold -= price * n;
    p.camels += n;
    p.totalSpent += price * n;
    UI.log(`${p.name} bought ${n} camels at $${price}`);
    SoundFX.buy(); // ğŸ”Š Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø´Ø±Ø§Ø¡
  },

  sell(p, n) {
    const price = GameState.prices[GameState.currentTown];
    if (p.camels < n) return UI.log(`${p.name} has not enough camels.`);
    const avg = p.camels ? (p.totalSpent / p.camels) : 0;
    p.camels -= n;
    p.gold += price * n;
    p.totalSpent -= avg * n;
    UI.log(`${p.name} sold ${n} camels at $${price}`);
    SoundFX.sell(); // ğŸ”Š Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¨ÙŠØ¹
  }
};

/* =========================================
   MODULE 4: Game Flow â€” Round-based & synchronized dice
   - Ensures dice work from the very first roll
   - Ignores double numbers (1â€“1, 2â€“2, etc.)
   ========================================= */
const GameFlow = (function () {
  let actionsTaken = 0;
  let roundNumber = 1;

  // ğŸ² Roll both dice and ensure callback works from the first roll
  async function rollValidDice() {
    try {
      const { green, red } = await rollDiceWithPromise();
      processDiceResults(green, red);
    } catch (err) {
      console.error("rollValidDice error:", err);
      UI.log("âš ï¸ Dice error â€” fallback random rolls used.");
      processDiceResults(random1to6(), random1to6());
    }
  }

  // ğŸŒ€ Promise-based dice roll that guarantees callback
  function rollDiceWithPromise() {
    return new Promise((resolve) => {
      Dice3D.onRollDone(({ green, red }) => resolve({ green, red }));
      const result = Dice3D.rollBoth();

      // Ù„Ùˆ Ù„Ù… ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ callback Ù„Ø£ÙŠ Ø³Ø¨Ø¨ (Ø£ÙˆÙ„ Ù…Ø±Ø© Ù…Ø«Ù„Ø§Ù‹)
      setTimeout(() => resolve(result), 1500);
    });
  }

  function random1to6() {
    return Math.floor(Math.random() * 6) + 1;
  }

  // ğŸ¯ Process dice results and move caravan
function processDiceResults(g, r) {
  SoundFX.diceRoll(); // ğŸ”Š ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ù†Ø±Ø¯ ÙÙˆØ±Ù‹Ø§

  // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ØªØ·Ø§Ø¨Ù‚Ø© (1ØŒ1 Ø£Ùˆ 5ØŒ5 ...)
  if (g === r) {
    const msg = `ğŸ² Dice rolled double (${g},${r}) â€” ignored, rolling again...`;
    UI.log(msg);
    if (typeof Notifications !== "undefined")
      Notifications.show(msg, { level: "info", duration: 2000 });
    setTimeout(rollValidDice, 1400);
    return;
  }

  // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù†Ø±Ø¯
  UI.greenDie.textContent = g;
  UI.redDie.textContent = r;
  UI.greenDie.classList.add("roll");
  UI.redDie.classList.add("roll");
  setTimeout(() => {
    UI.greenDie.classList.remove("roll");
    UI.redDie.classList.remove("roll");
  }, 600);

  const currentPrice = GameState.prices[GameState.currentTown];
  let usedGreen = true, usedRed = true;

  if (currentPrice === 1) {
    usedRed = false;
    UI.log("â„¹ï¸ Bottom city: ignoring RED die.");
  } else if (currentPrice === 100) {
    usedGreen = false;
    UI.log("â„¹ï¸ Top city: ignoring GREEN die.");
  }

  let diff = 0;
  let direction = "none";

  if (usedGreen && !usedRed) {
    diff = g;
    direction = "green-only";
  } else if (!usedGreen && usedRed) {
    diff = r;
    direction = "red-only";
  } else if (usedGreen && usedRed) {
    if (g > r) { diff = g - r; direction = "up"; }
    else if (r > g) { diff = r - g; direction = "down"; }
  }

  const msg = `ğŸ² Dice: Green ${g} | Red ${r} â†’ ${direction.toUpperCase()} ${diff}`;
  UI.log(msg);
  if (typeof Notifications !== "undefined")
    Notifications.show(msg, { level: "important", duration: 2000 });

  if (diff <= 0) {
    UI.log("ğŸª Caravan stays in place this round.");
    UI.updateTown();
    UI.refreshTable();
    positionPlayers();
    UI.highlightActivePlayer();
    return;
  }

  const prevIndex = GameState.currentTown;
  let newIndex = prevIndex;

  if (direction === "green-only" || direction === "up")
    newIndex = Math.min(GameState.towns.length - 1, prevIndex + diff);
  else if (direction === "red-only" || direction === "down")
    newIndex = Math.max(0, prevIndex - diff);

  GameState.currentTown = newIndex;
  const newTown = GameState.towns[newIndex];
  const newPrice = GameState.prices[newIndex];

  UI.log(`ğŸª Caravan moved to ${newTown} â€” Price $${newPrice}`);
  SoundFX.caravanMove(); // ğŸ”Š ØµÙˆØª Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ø§ÙÙ„Ø©
  if (typeof Notifications !== "undefined")
    Notifications.show(`ğŸª Caravan reached ${newTown} ($${newPrice})`, { level: "good", duration: 2500 });

  UI.updateTown();
  UI.refreshTable();
  positionPlayers();
  UI.highlightActivePlayer();
}

  window.processDiceResults = processDiceResults;

  return {
    playerActed() {
      actionsTaken++;
      UI.log(`âœ… Action registered (${actionsTaken}/${GameState.players.length})`);

      if (actionsTaken >= GameState.players.length) {
        actionsTaken = 0;
        roundNumber++;
        UI.log(`ğŸ”” All players acted â€” rolling dice for round ${roundNumber}`);
        setTimeout(() => rollValidDice(), 600);
      }

      this.advanceActivePlayer();
    },

advanceActivePlayer() {
  GameState.activeIndex = (GameState.activeIndex + 1) % GameState.players.length;
  UI.refreshTable();
  UI.highlightActivePlayer();

  const current = GameState.players[GameState.activeIndex];
  SoundFX.nextTurn(); // ğŸ”Š ØµÙˆØª Ø¹Ù†Ø¯ ØªØºÙŠØ± Ø§Ù„Ø¯ÙˆØ±
  if (current && current.isAI) aiTakeTurn(current);
},

    getRoundNumber() { return roundNumber; },
    resetRound() { actionsTaken = 0; UI.log("ğŸ” Round counters reset."); }
  };
})();

/* =========================================
   MODULE 5: Setup and Event Handlers
   ========================================= */
function init(){
	window.addEventListener("click", () => {
  if (SoundFX.ctx.state === "suspended") SoundFX.ctx.resume();
}, { once: true });
  GameState.towns.forEach((t,i)=>UI.createNode(i,t,GameState.prices[i]));
  UI.updateTown();
  UI.log("âœ… Ready");
}

function addPlayer(name, isAI = false) {
  if (!name) return;
  const color = GameState.palette[GameState.players.length % GameState.palette.length];
  const p = {
    name,
    gold: 10,
    camels: 0,
    totalSpent: 0,
    isAI,
    color, // âœ… store color for table use
    dotEl: document.createElement("div")
  };

  p.dotEl.className = "player-dot";
  p.dotEl.style.background = color;
  p.dotEl.style.color = color; // ğŸ†• added line for glowing in player color

  GameState.players.push(p);
  UI.map.appendChild(p.dotEl);

  positionPlayers();
  UI.refreshTable();
  UI.log(`${name} joined ${isAI ? "(AI)" : ""}`);
}

function positionPlayers() {
  const node = document.querySelector(`.node[data-index="${GameState.currentTown}"]`);
  if (!node) return;

  // Get town center in map coordinates
  const nodeRect = node.getBoundingClientRect();
  const mapRect = UI.map.getBoundingClientRect();
  const centerX = nodeRect.left - mapRect.left + nodeRect.width / 2;
  const centerY = nodeRect.top - mapRect.top + nodeRect.height / 2;

  // Inner circle radius (smaller than town circle)
  const total = GameState.players.length;
  const radius = 10; // small circle within the town

  GameState.players.forEach((p, i) => {
    let x = centerX;
    let y = centerY;

    if (total > 1) {
      const angle = (i / total) * 2 * Math.PI;
      // Distribute them slightly around the center so they don't overlap
      x += radius * Math.cos(angle);
      y += radius * Math.sin(angle);
    }

    p.dotEl.style.left = `${x}px`;
    p.dotEl.style.top = `${y}px`;
  });
}

document.getElementById("addPlayerBtn").onclick=()=>{
  addPlayer(document.getElementById("newPlayerName").value,false);
  document.getElementById("newPlayerName").value="";
};
document.getElementById("addAIPlayerBtn").onclick=()=>{
  addPlayer("Robot"+(GameState.players.length+1),true);
};

document.getElementById("startBtn").onclick = () => {
  if (GameState.players.length === 0) return UI.log("Add players first!");
  GameState.started = true;
  UI.log("ğŸ® Game started!");
  UI.highlightActivePlayer();
  UI.refreshTable();

  // ğŸš€ If first player is AI, start its turn automatically
  const first = GameState.players[GameState.activeIndex];
  if (first.isAI) aiTakeTurn(first);
};

document.getElementById("resetBtn").onclick=()=>location.reload();

/* =========================================
   MODULE 6: AI Trader Pro ğŸ¤–ğŸ’° (SMART VERSION)
   - Waits 2s before decision
   - Groups all robot logs into one elegant notification
   - Caravan moves only after all players finish
   ========================================= */
function aiTakeTurn(p) {
  // ğŸ§  Start thinking phase
  UI.log(`ğŸ¤– ${p.name} is analyzing market trends... (thinking...)`);
  Notifications.aiLog(`ğŸ¤– ${p.name} is analyzing market trends...`);

  setTimeout(() => {
    const price = GameState.prices[GameState.currentTown];
    const townName = GameState.towns[GameState.currentTown];

    // ğŸ—ºï¸ Log AIâ€™s situational awareness
    if (typeof lastMovedTown === "undefined") {
      UI.log(`ğŸ¤– ${p.name} starts analysis at ${townName}.`);
      Notifications.aiLog(`ğŸ“ Starting analysis in ${townName}.`);
    } else if (lastMovedTown === GameState.currentTown) {
      UI.log(`ğŸ¤– ${p.name} notices caravan still in ${townName}.`);
      Notifications.aiLog(`ğŸ“ Caravan still in ${townName}.`);
    }

    lastMovedTown = GameState.currentTown;

    const gold = p.gold;
    const camels = p.camels;

    // ğŸª Buying strategy
    if (price < 10 && gold >= price) {
      const budgetFactor = (10 - price) / 10;
      let spendAmount = gold * budgetFactor;
      if (price === 1) spendAmount = gold * 0.95;
      const n = Math.max(1, Math.floor(spendAmount / price));

      PlayerActions.buy(p, n);
      UI.log(`ğŸ¤– ${p.name} found a cheap market ($${price}) and bought ${n} camels.`);
      Notifications.aiLog(`ğŸŸ¢ Cheap market ($${price}) â€” bought ${n} camels.`);
    }

    // ğŸ’° Selling strategy
    else if (price >= 70 && camels > 0) {
      const avg = camels ? (p.totalSpent / camels) : 0;
      const profitRatio = price / (avg || 1);
      let n = 0;

      if (price >= 90) {
        n = camels;
        PlayerActions.sell(p, n);
        UI.log(`ğŸ¤– ${p.name} sees premium prices! Selling ALL camels at $${price}.`);
        Notifications.aiLog(`ğŸ’ Premium market ($${price}) â€” sold ALL ${n} camels.`);
      } else if (profitRatio >= 1.2) {
        n = Math.ceil(camels * 0.6);
        PlayerActions.sell(p, n);
        UI.log(`ğŸ¤– ${p.name} takes profits and sells ${n} camels at $${price}.`);
        Notifications.aiLog(`ğŸ’° Profitable market â€” sold ${n} camels.`);
      } else {
        n = Math.ceil(camels * 0.3);
        PlayerActions.sell(p, n);
        UI.log(`ğŸ¤– ${p.name} sells ${n} camels cautiously at $${price}.`);
        Notifications.aiLog(`âš–ï¸ Mild profit â€” sold ${n} camels cautiously.`);
      }
    }

    // ğŸ¤” Waiting strategy
    else {
      UI.log(`ğŸ¤– ${p.name} decides to WAIT for a better opportunity.`);
      Notifications.aiLog(`â³ Waits for better prices.`);
    }

    // âœ… Finalize AI summary
    Notifications.aiLog("", true);

    // ğŸ§¾ Refresh player info and proceed to next turn

UI.refreshTable();
GameFlow.playerActed();   // âœ… ÙŠØ³Ø¬Ù‘Ù„ Ø§Ù„ÙØ¹Ù„ Ø¨Ø¯Ù„ Ù…Ø§ ÙŠØ¨Ø¯Ù‘Ù„ Ø§Ù„Ø¯ÙˆØ± ÙÙˆØ±Ù‹Ø§
  }, 4000);
}

/* =========================================
   MODULE 7: Smart Single-Line Notifications (Map)
   ========================================= */
const Notifications = (function () {
  let el = null;
  let aiBuffer = "";
  let showing = false;
  let hideTimer = null;

  // ğŸ§± Ensure notification element exists
  function ensure() {
    if (el) return;
    el = document.createElement("div");
    el.id = "smart-notif";
    el.setAttribute("role", "status");
    el.setAttribute("aria-live", "polite");
    el.style.pointerEvents = "none";

    // Attach inside the map (or fallback to body)
    const map = document.querySelector(".map");
    if (map) map.appendChild(el);
    else document.body.appendChild(el);

    // ğŸ’… Shimmer style
    const s = document.createElement("style");
    s.textContent = `
#smart-notif {
  position: absolute;
  bottom: 5px;
  left: 10px;
  z-index: 1000;
  pointer-events: none;
  font-family: system-ui, sans-serif;
  font-weight: 500;
  font-size: 14px;
  letter-spacing: 0.4px;
  white-space: nowrap;
  text-align: left;
  opacity: 0;
  -webkit-font-smoothing: antialiased;

  background: linear-gradient(90deg, #ffffff, #ffd166, #7be57b, #ffffff);
  background-size: 300%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: hueShift 6s linear infinite;

  transition: opacity 0.35s ease, transform 0.35s ease;
  text-shadow: 0 2px 10px rgba(0,0,0,0.45);
}

#smart-notif.visible {
  opacity: 1;
  transform: translateY(-6px);
}

#smart-notif:not(.visible) {
  transform: translateY(10px);
}

@keyframes hueShift {
  0%   { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}`;
    document.head.appendChild(s);
  }

function playChime() {
  try {
    if (typeof SoundFX !== "undefined") {
      SoundFX.diceRoll(); // âœ… Ø§Ø³ØªØ®Ø¯Ù… ØµÙˆØª Ø§Ù„Ù†Ø±Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ø¯Ù„ Ø§Ù„Ø¨ÙŠØ¨ Ø§Ù„Ù‚Ø¯ÙŠÙ…
    }
  } catch (e) { /* silent fail */ }
}

  // ğŸ§  Smart Replace Notification System
  function show(msg, opts = {}) {
    ensure();
    if (!msg) return;

    const level = opts.level || "info";
    const duration = opts.duration || (level === "important" ? 4200 : 2500);
    const sound = opts.sound ?? (level === "important");

    // If already showing â†’ fade out first, then show new
    if (showing) {
      el.classList.remove("visible");
      clearTimeout(hideTimer);
      setTimeout(() => displayNow(msg, duration, sound), 200);
    } else {
      displayNow(msg, duration, sound);
    }
  }

  function displayNow(msg, duration, sound) {
    showing = true;
    el.textContent = msg;
    el.classList.add("visible");
    if (sound) playChime();

    hideTimer = setTimeout(() => {
      el.classList.remove("visible");
      setTimeout(() => {
        el.textContent = "";
        showing = false;
      }, 300);
    }, duration);
  }

  // ğŸ¤– AI message grouping (summarized)
  function aiLog(line, done = false) {
    if (line && line.trim()) {
      if (aiBuffer) aiBuffer += " Â· ";
      aiBuffer += line.trim().replace(/\s+/g, " ");
      if (aiBuffer.length > 160) aiBuffer = aiBuffer.slice(0, 157) + "â€¦";
    }
    if (done && aiBuffer) {
      show(aiBuffer, { level: "good", duration: 5200 });
      aiBuffer = "";
    }
  }

  return { show, aiLog };
})();

/* =========================================
   MODULE: Dynamic Map + Sidebar Resizer
   ========================================= */
(function() {
  const container = document.querySelector(".container");
  const map = document.querySelector(".map");
  const sidebar = document.querySelector(".sidebar");

  // ğŸ§± Fix spacing
  container.style.display = "flex";
  container.style.gap = "0";
  container.style.alignItems = "flex-start";

  // ğŸª„ Create drag handle
  const handle = document.createElement("div");
  handle.id = "resizeHandle";
  handle.style.width = "8px";
  handle.style.cursor = "ew-resize";
  handle.style.background = "linear-gradient(180deg, #d6b370, #b87b2c)";
  handle.style.borderLeft = "2px solid #7a4f1a";
  handle.style.borderRight = "2px solid #7a4f1a";
  handle.style.height = "100%";
  handle.style.boxShadow = "inset 0 0 5px rgba(0,0,0,0.3)";
  container.insertBefore(handle, sidebar);

  // ğŸ–±ï¸ Handle drag logic
  let dragging = false;
  handle.addEventListener("mousedown", () => dragging = true);
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    const rect = container.getBoundingClientRect();
    let newWidth = e.clientX - rect.left;
    newWidth = Math.max(400, Math.min(1100, newWidth)); // limit
    map.style.width = newWidth + "px";
  });

  // ğŸ§­ Optional: Adjust sidebar to fill rest
  sidebar.style.flex = "1";
})();




init();
</script>
<script src="musicControl.js"></script>
<script src="soundFX.js"></script>
</body>
</html>
